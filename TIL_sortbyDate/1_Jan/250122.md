원시 자료형과 참조 자료형의 차이(메모리 적재 측면)
- 원시 자료형은 힙 메모리에 값 자체가 저장된다.
- 참조 자료형은 객체나 배열의 형태이다. 힙 메모리에 해당 값들이 저장되고 스택 메모리에는 힙 메모리의 주소가 저장된다.

변수 유형
- 지역 변수 : 메서드 안에 선언
- 매개 변수 : 메서드의 입력값
- 인스턴스 변수 : 객체가 고유한 값을 가지고 싶을 때 설정
- 클래스 변수 : 한 클래스에서 파생되는 객체들이 공유하는 변수, ```static```

클래스 : 관련된 속성과 메서드를 묶어서 객체를 생성하기 위한 탬플릿 -> 그럼 객체란? 클래스의 인스턴스나 배열(Java Language Specification)
- 코드를 직관적으로 쉽게 볼 수 있고, 재사용성과 유지보수성을 높이기 위해 사용함

메서드 오버로딩 VS 메서드 오버라이딩
- 메서드 오버로딩 : 유사한 역할을 하지만 받는 파라미터가 다른, 이름이 중복된 메서드
- 메서드 오버라이딩 : 상속한 메서드를 재정의하는 행위(어노테이션 ```@Override```)

흔히 사용하는 public static void main(String[] args)는 도대체 뭐냐?
- public : 접근 제어자, JVM이 처음으로 실행하는 메서드인데 protected, default, private같은 제어자로 있으면 다른 파일에 import된 라이브러리를 읽을 수 없기 때문에 public임
- static : main메서드는 처음 시작되고 종료될 때까지 메모리에 적재되어 있어야 함. 그러므로 static을 사용하여 메서드 메모리 영역에 적재함
- void : main메서드는 반환값이 없음. 그러므로 void
- String[] args : 일반 IDE로 실행시키면 사용할 일이 없지만, 커맨드 라인을 통해 main메서드를 통해 String 배열 데이터를 넘길 수 있음.

private static을 사용하는 이유?
- 복습하자면, private는 해당 클래스에서의 접근만 허용하고, static은 해당 클래스의 인스턴스(객체)를 통하지 않고도 접근 가능하다.
- 다른 클래스에서 해당 변수나 메서드에 접근하는 것을 막고, 해당 클래스에서 공통적으로 사용해야 하는 경우 static을 붙인다.
- 관련된 내용을 찾다보니, final이 나오는데, final은 어떨 때 쓰는걸까?

final
- final로 선언하면 해당 엔티티에 단 한번만 할당이 가능하다.
  - 원시 자료형의 경우 재할당이 불가능하고, 객체 타입에 선언 시 다른 참조값을 넣을 수 없다(setter로 객체 안 값을 바꿀수는 있다.)