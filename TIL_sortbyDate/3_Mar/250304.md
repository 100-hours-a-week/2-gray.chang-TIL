<img src="/Tracking_Time/3_Mar/250304.png">

### 데이터베이스 : 자료를 활용하기 위해 구조화해놓은 데이터 모음
- 자료를 테이블(표) 형식으로 구조화하여 데이터의 안정성과 신뢰성을 보장한다.(RDB)
  - 그렇다면, 자료를 테이블로 저장하는 방법밖에 없나? => no
  - 계층형 데이터베이스 : 폴더와 파일 등의 계층형으로 데이터를 구조화
  - 네트워크형 데이터베이스 : 노드-엣지의 논리로 네트워크 구조로 데이터를 구조화
- 키의 종류
  - 후보 키(candidate key) : 유일성과 최소성을 만족하는 키
    - 유일성 : 각각의 튜플을 유일하게 식별할 수 있는 특징
    - 최소성 : 튜플을 구성하기 위해 최소한의 컬럼만 사용하는 특징
  - 기본 키(primary key) : 후보 키 중에 선택된 키, null이 들어갈 수 없으며 중복데이터를 허용하지 않는다.
  - 대체 키(surrogate key) : 후보 키 중 기본키가 아닌 나머지 키
  - 외래 키(foreign key) : 다른 테이블의 기본 키를 참조하는 속성
  - 슈퍼 키(super key) : 유일성을 만족하는 키, 최소성은 보장하지 않는다.
- 컬럼에서 사용할 수 있는 타입
  - BOOLEAN
  - INT
  - FLOAT
  - VARCHAR(n) : 최대 n바이트의 문자열을 저장할 수 있는 타입
    - n이 바이트 기준인데, 영어랑 한글이랑 숫자랑 차이가 있겠네?
      - 맞음! 인코딩을 어떻게 하냐에 따라 달라지는데, 자주 쓰이는 UTF-8 기준 영어는 알파벳 하나에 1byte, 한글은 3byte 사용됨.(일부 특수문자는 4byte)
  - CHAR(n) : n바이트의 고정된 문자열만 저장 가능
  - TEXT : 최대 65535byte 길이의 매우 긴 문자열(64KB)
  - DATE(yyyy-mm-dd)
  - DATETIME(yyyy-mm-dd hh:mm:ss)
  - TIMESTAMP(yyyy-mm-dd hh:mm:ss) : 내가 저장 안해도 기본적으로 저장되는 값(게시글 생성일시 등)

### 정규화 : 관계형 데이터베이스에서 중복을 최소화하기 위해 데이터베이스를 설계하는 과정
- 이상현상(Anomaly)를 줄이기 위해 사용
  - 삽입이상 : 데이터 삽입 시 원하지 않는 값까지 추가해야 하는 현상
  - 삭제이상 : 데이터 삭제 시 원하지 않는 값까지 삭제되는 현상
  - 갱신이상 : 데이터 갱신 시 데이터 중복으로 일관성이 없어지는 현상
- 통상 실무에서는 1~3정규형을 사용한다.
  - 1정규형 : 각 열은 더이상 분해할 수 없는 한가지 정보만을 담고 있어야 한다.(원자성을 띄어야 한다.)
    
    |        이메일         |   비밀번호   |            핸드폰번호            |
    |:------------------:|:--------:|:---------------------------:|
    | yhyh4420@gmail.com | password | 010-0000-0000,<br/>010-1111-0000 |

    |        이메일         |   비밀번호   |     핸드폰번호     |
        |:------------------:|:--------:|:-------------:|
    | yhyh4420@gmail.com | password | 010-0000-0000 | 
    | yhyh4420@gmail.com | password | 010-1111-0000 |

  - 2정규형 : 컬럼들이 기본키가 아닌 다른키에 종속되는 것을 방지
    - 말로는 이해하기 어려운데, 오로지 기본 키로만 컬럼을 구분할 수 있어야 한다는 뜻이다.
    - | id | 이름  | 주문품목 | 물건가격 | 주문수량 |
      |:--:|:---:|:----:|:----:|:----:|
      | 1  | aaa |  맥북  | 1000 |  2   |
      | 2  | bbb |  맥북  | 1000 |  2   |
      | 3  | bbb | 아이폰  | 500  |  1   |
    - 위 테이블은 1정규형은 만족하지만 물건가격의 경우 주문품목에 종속됨. 즉 주문품목이 맥북이면 물건갸격은 무조건 1000이라는 뜻
    - 그러니까 쪼개야 한다.
      - | id | 이름  | 주문품목 | 주문수량 |
        |:--:|:---:|:----:|:----:|
        | 1  | aaa |  맥북  |  2   |
        | 2  | bbb |  맥북  |  2   |
        | 3  | bbb | 아이폰  |  1   |
      
      - | 주문품목 | 물건가격 |
        |:----:|:----:|
        |  맥북  | 1000 |
        | 아이폰  | 500  |
  
  - 3정규형 : 2정규형을 만족하는데, A 컬럼이 B에 종속되고, B가 C에 종속되는 이행 종속을 제거하기 위해 테이블을 분리
  - | 주문번호 | 	고객ID | 	고객이름 | 	고객주소 |
    |:----:|:-----:|:-----:|:-----:|
    |  1   | A100  |  aaa  |  강남   |
    |  2   | B200  |  bbb  |  강북   |
    |  3   | C300  |  ccc  |  강서   |
    - 위 테이블은 주문번호만으로 컬럼을 구분할 수 있어 2정규형을 만족한다. 하지만 고객 id로 인해 고객이름이 결정되고, 고객이름에 의해 고객주소가 결정되므로 분리해야 한다.
      - | 주문번호 | 고객ID |
        |:----:|:----:|
        |  1   | A100 |
        |  2   | B200 |
        |  3   | C300 |
  
      - | 고객ID | 고객이름 | 고객주소 |
        |:----:|:----:|:----:|
      - | A100 | aaa  |  강남  |
      - | B200 | bbb  |  강북  |
      - | C300 | ccc  |  강서  |

### JOIN : 두개 이상의 테이블을 관련된 컬럼으로 결합하여 하나의 테이블처럼 조회
```sql
SELECT 출력할 컬럼들
FROM table1
JOIN table2
ON 조건문
```
- join의 종류 : inner join, left outer join, right outer join, full outer join
  - inner join : 교집합 연산과 동일, 공통적으로 존재하는 데이터만 조인해서 결과를 추출
  - left outer join : inner join + table1의 값을 보여줌, 이때 컬럼값이 없다면 null로 표시
  - right outer join : inner join + table2의 값을 보여줌, 이때 컬럼값이 없다면 null로 표시
  - full outer join : inner join값을 포함한 모든 값을 보여줌, 이때 컬럼값이 없다면 null로 표시
- join은 신중하게 써야 한다.
  - inner join은 null이 없지만 outer join의 경우 null체크하는 로직이 추가되어 inner join보다 느리게 된다.

### VIEW : 필요한 값들을 모아놓은 가상의 테이블
- join은 검색 속도를 늦출 수 있다. 그래서 미리 가상의 테이블을 만들어 데이터 조회를 빠르게 한다.
- 가상의 테이블을 생성하기 때문에 실제 데이터 처리 속도에는 영향을 미치지 않는다. 따라서 테이블 설계에 따라 적절하게 실제 테이블을 조작할지, 뷰를 만들지 선택해야 한다.
- Materialized View : 쿼리의 결과를 미리 계산하여 저장하는 **실제 테이블**
  - 일반 view는 가상의 테이블이고 materialized view는 기존 테이블의 값들을 저장해놓은 실제 테이블이다.
  - 일반 view는 쿼리가 실행될 때마다 기존 테이블을 계산하여 실시간으로 생성되고, materialized view는 쿼리의 결과가 사전에 계산되어있어 정적으로 유지됨
  - 일반 view는 원본 데이터에 접근하여 조회하기 때문에 속도가 느리고, materialized view는 이미 만들어진 테이블에서 가져오므로 조회속도가 빠르다.
  - 일반 view는 쿼리가 실행될 때마다 기존 테이블에 접근하기 때문에 변경사항이 즉시 반영되지만, materialized view는 수동으로 업데이트 쿼리를 실행해야 한다.```REFRESH MATERIALIZED VIEW 뷰이름```

### UNION : 서로 다른 쿼리의 결과를 합치는 과정
```sql
SELECT 출력할컬럼들
FROM 테이블1
UNION
SELECT 출력할컬럼들
FROM 테이블2
```
다른 테이블의 select문을 합친다는 장점이 있지만 대규모 데이터셋을 합칠 경우 성능 저하를 일으킬 수 있다. 특히 UNION은 중복을 제거하기 때문에 이 과정에서 추가적인 리소스 소모를 일으킬 수 있다.