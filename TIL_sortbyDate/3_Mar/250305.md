<img src="/Tracking_Time/3_Mar/250305.png">

### INDEX : 테이블에 대한 조회 속도를 높여주는 자료구조
- B-tree : 트리 자료구조의 일종
  - 하나의 노드가 여러 정보를 가질 수 있으며, 트리의 깊이를 균형있게 유지하여 복잡도를 일정하게 유지함
  - 데이터베이스 인덱스에서 자주 사용되며, 대용량 데이터 처리에 유리함
- B+tree : mysql innodb에서 데이터를 관리하는 자료구조
  - innodb : mysql을 위한 데이터베이스 엔진
  - 리프 노드는 연결리스트로 서로 연결되어 서로 다른 리프여도 조회 가능 => 범위 조회가 용이하다
  - 실제 데이터는 리프 노드에만 저장되어있다.

### 카디널리티 : 각 컬럼이 가질 수 있는 데이터 종류
- 값 중복이 많다면 카디널리티가 낮고(성별) 값 중복이 적다면 카디널리티가 높음(주민등록번호, 이름 등)

### 트랜잭션 : 데이터베이스에 대해 실행하는 작업의 단위
- 트랜잭션의 상태는 활성, 실패, 철회, 부분 완료, 완료가 있다.
  - 활성(active) : 트랜잭션이 시작된 상태
  - 실패(failed) : 에러나 다른 예외 등 오류에 의해 더이상 작업이 진행되지 않는 상태
  - 철회(aborted) : 실패한 트랜잭션을 실행 이전으로 롤백
  - 부분 성공(partially committed) : 트랜잭션이 성공했고, 커밋 명령만 남은 상태
  - 성공(committed) : 트랜잭션 성공 상태를 데이터베이스에 영구적으로 저장

- ACID : 트랜잭션이 안전하게 수행되기 위한 4가지 조건
  - Atomicity : 트랜잭션은 성공하거나 실행되지 않거나(rollback) 둘 중 하나여야 한다.
  - Consistently : 트랜잭션의 작업 처리 결과는 항상 일관성과 정합성이 보장되어야 한다.
    - 일관성 : 트랜잭션 실행 전후 데이터베이스 상태가 일관되어야 함
    - 정합성 : 언제나 같은 입력에는 같은 값이 나와야 함
  - Isolation : 동시에 다수 쿼리가 실행되었을 때 발생하는 모든 쿼리는 독립되어야 함
    - 어떤 트랜잭션도 다른 트랜잭션 실행 중 연산에 끼어들 수 없다.
    - Isolation level : 특정 트랜잭션이 실행중일 때 내부 데이터를 다른 트랜잭션에서 변경하거나 읽을 수 있게 허용하는 정도
      - 레벨이 낮을수록 고립성이 낮고 동시성이 높고, 레벨이 높을수록 고립성이 높고 동시성이 낮다. 
      - READ UNCOMMITTED : 트랜잭션의 커밋, 롤백에 관련없이 트랜잭션 도중 데이터를 조회할 수 있음
      - READ COMMITTED : 커밋이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회할 수 있음
      - REPEATABLE READ : 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있음
      - SERIALIZABLE : 하나의 트랜잭션에서 읽고 쓰는 레코드는 다른 트랜잭션에서 절대 접근할 수 없음
    - 트랜잭션 고립 수준에 따라 발생하는 문제 : Dirty Read, Non-Repeatable Read, Phantom read
      - Dirty Read : 트랜잭션 중간에 데이터를 읽음
      - Non-Repeatable Read : 데이터 변경 트랜잭션 중 데이터를 읽는 트랜잭션이 두번 실행되면 데이터가 달라짐
      - Phantom Read : 데이터 추가 트랜잭션 중 데이터를 읽는 트랜잭션이 두번 실행되면 없던 데이터가 새로 읽혀짐
  - Durability : 트랜잭션이 성공하면 해당 결과는 영구적으로 저장되어야 한다.

### NoSQL : Not Only SQL
- 정형 데이터 뿐만 아니라 반정형, 비정형 데이터도 저장 가능한 데이터베이스
- 데이터 구조에 따라 key-value, document, column, graph로 구분됨
  - key-value store : 각 키에 하나의 값이 매핑되는 가장 단순한 데이터 저장 방식
  - document oriented databases : json, xml과 같은 형식으로 데이터 저장  
  - column-based databases : 컬럼 단위로 데이터 저장, 대량의 데이터 빠르게 조회 및 분석 가능
  - graph databases : 노드와 엣지로 객체간 관계를 표현하고 데이터를 저장 및 조회함

### Evential Consistency : 실시간 일관성이 아닌 일정 시간이 지난 후 데이터 일관성을 보장하는 모델
- 즉, 지금 당장은 아니더라도 나중에라도 트랜잭션이 실행됨을 보장한다.
- NoSQL가 채택하는 일관성 모델로, 이로 인해 데이터 무결성을 직접 관리해야 한다. 
- 낙관적 동시성 제어 같은 기법을 사용한다 => 트랜잭션 시작 시 충돌 가능성을 점검하지 않고 트랜잭션 완료 후 충돌여부를 체크하여 충돌했으면 롤백함


### CAP 이론 : Consistency, Availability, Partition tolerance 중 두가지만 만족할 수 있음
- Consistency : 모든 사용자가 데이터베이스의 최신 상태를 동일하게 볼 수 있어야 함
- Availability : 시스템의 일부가 고장나더라도 데이터베이스 전체의 서비스가 계속 유지되어야 한다.
- Partition tolerance : 네트워크 오류가 발생해도 시스템이 작동해야 한다.
- Consistency와 Availability는 네트워크 파티션(네트워크 장애)이 발생했을 때 두가지를 동시에 만족할 수 없기에 트레이드 오프 관계이다
  - CP 시스템 예시 : 은행계좌 시스템
    - 네트워크 장애가 발생해도 모든 서버는 최신 계좌상태를 가지고 있어야 한다.
    - 대신 네트워크 장애 시 데이터를 확인하지 못하게 한다.
  - AP 시스템 예시 : SNS 시스템
    - SNS시스템은 일단 사용자에게 보여주는 것이 중요하다.(가용성)
      - 대신 네트워크 장애 시 최신 게시글을 동기화하지 않을 수 있다. 하지만 Evential Consistency하다.

### 객체지향 4대요소 (면접에서 답변한다 생각하고 간결하게 정리)
- 객체지향의 4대요소에는 캡슐화, 상속, 다형성, 추상화가 있다.
- 캡슐화 : 외부에서 객체 내 데이터와 메서드로 직접 접근하는 것을 제한하여 내부 구현을 숨기는 것
  - 객체 내 데이터 은닉, 데이터 보호 및 유지보수 가능
- 상속 : 기존의 클래스의 메서드를 물려받아 새로운 클래스를 만드는 것
  - 코드 재사용성 증가, 유지보수성 증가, 클래스간 관계 설명 용이
- 다형성 : 같은 이름의 메서드더라도 다른 객체 타입에서 다르게 동작하도록 하는 능력
  - @Override를 통해 구현, 코드를 유연하게 짤 수 있음
- 추상화 : 불필요한 로직 대신 핵심 개념만 표현하여 복잡성을 관리
  - abstract(구현 강제 안함), interface(구현 강제)로 구현 가능



B-Tree와 B+Tree의 차이점과 각각의 사용 사례를 설명해주세요.

카디널리티가 낮은 컬럼에 인덱스를 생성하는것이 왜 비효율적인지 설명해주세요.

커버링 인덱스가 성능 향상에 도움이 되는 이유를 설명해주세요.

트랜잭션 격리 수준별로 발생 가능한 문제를 설명해주세요.

분산 시스템에서 ACID를 보장하기 어려운 이유를 설명해주세요.

CAP 이론에서 Consistency와 Availability의 트레이드오프를 예시와 함께 설명하라.

Eventual Consistency를 사용하는 시스템에서 데이터 충돌을 해결하는 방법을 설명해주세요.

MongoDB와 RDBMS의 스키마 설계 차이점을 설명해주세요.