<img src="/Tracking_Time/3_Mar/250318.png">

### ORM : 자바와 같은 객체지향적 언어에서 관계형 데이터베이스와 매핑하기 위해 사용되는 기술
- ORM 장점
  - SQL작성 감소 : JPA가 자동으로 CRUD 쿼리를 수행시켜줌 
  - 생산성 : 복잡하고 반복되는 쿼리 대신 비즈니스 로직에만 신경쓰면 됨
  - 유지보수성 : 테이블 스키마 변경 시 엔티티 매핑만 수정하면 됨
  - 객체지향적 설계 : 데이터베이스를 객체처럼 사용할 수 있는 기술이기 때문에 객체지향적이다.
- ORM 단점
  - 복잡한 쿼리 : SQL만큼 유연하지 않기 때문에 복잡한 쿼리를 수행해야 할 경우 native query를 쓴다.
  - 성능 저하 : 중간에 매핑을 처리하는 과정이 있기 때문에 약간의 성능 저하가 발생할 수 있다.

### JPA : 자바 플랫폼을 위한 ORM 기술 표준
- JPA는 자바 내에서 ORM기술을 잘 쓰기 위한 인터페이스다. Hibernate는 이를 실제로 수행하는 구현체이다.

### JPA 주요 어노테이션
- @Entity : 클래스를 JPA 엔티티로 선언, DB테이블과 매핑됨
  - @Table : 엔티티와 매핑될 테이블 이름 지정(생략 가능, 생략시 클래스명이 테이블명이 됨)
- @Id : 엔티티 식별자(반드시 하나 이상 설정해야 함)
  - @GeneratedValue : PK 생성 전략
    - IDENTITY : DB의 auto-increment 전략을 따름(mySQL, PostgreSQL)
    - SEQUENCE : 시퀀스 객체(오라클)
    - IDENTITY와 SEQUENCE의 차이점
      - IDENTITY : 1씩 자동으로 증가함
        - 식별자 할당 전에 엔티티를 먼저 DB에 저장함 -> 그 후 해당 엔티티에 식별자 할당
        - flush가 트랜잭션 종료 시점이 아니라 save()때이다.
      - SEQUENCE : allocationSize를 설정하여 한 트랜잭션에서 설정할 인덱스의 사이즈를 미리 할당함.(default : 50)
        - em.persist()호출 전 식별자를 먼저 조회함 -> 그 후 조회한 식별자를 엔티티에 할당
        - flush는 트랜잭션 종료 시점이다.
- @Column : 컬럼명 및 해당 컬럼의 DDL 정의
- @Transient : 영속성 관리에서 제외하고 싶을 때 사용, 주로 임시 값을 저장할 때 사용된다.
- @Enumerated : Enum 타입을 데이터베이스에 저장할 때 사용
  - EnumType.ORDINAL : Enum의 순서를 저장(사용하지 말자, Enum 클래스의 순서가 바뀌면 DB 다시 매핑해야된다)
  - EnumType.String : Enum의 이름을 문자열로 저장

### 엔티티와 영속성 컨텍스트
- 엔티티 : DB테이블의 한 행을 객체로 매핑한 것, 식별자와 컬럼으로 구분함.
- 영속성 컨텍스트 : 엔티티를 영구적으로 저장/관리하는 공간
  - 1차 캐시 : 동일 트랜잭션 내, 같은 PK 조회 시 DB 대신 캐시 사용
    - 동일 트랜잭션 내 같은 pk의 엔티티 재조회 시 select 쿼리를 추가 실행하지 않고 1차캐시에 저장되어있는 엔티티를 반환한다.
  - 변경 감지(Dirty Checking) : 엔티티 수정 시 트랜잭션 커밋 시점에 자동으로 update
    - 영속성 컨텍스트에 진입 시 엔티티 스냅샷을 1차캐시에 보관해놓고 트랜잭션이 종료되어 커밋하는 상황이나 flush 시 스냅샷과 비교하여 update한다.
  - 지연 로딩(Lazy Loading) : 연관관계 엔티티를 필요 시점에 DB로부터 로딩
    - 엔티티를 가져올 때 관련된 엔티티를 실제 사용 시점에 가져옴. 이때 실제 엔티티를 상속받는 프록시 객체가 사용된다.
- 영속성 컨텍스트는 EntityManager(혹은 Repository)에서 관리되며, 트랜잭션 종료 후 대부분 초기화됨
- 엔티티 생명주기
  - 비영속 : 영속성 컨텍스트에 등록되지 않은 상태(new로 생성된 단순 객체)
  - 영속 : em.persist() 등으로 영속성 컨텍스트에 등록된 상태
  - 준영속 : 영속성 컨텍스트에 등록되었으나 영속성 컨텍스트에서 분리되어(트랜잭션 종료, em.detach() 등) 더이상 영속성 컨텍스트에서 관리하지 않는 상태
  - 삭제 : remove()로 삭제 요청된 상태
- EntityManager는 영속성 컨텍스트와 1차캐시를 가지고 있기 때문에 thread-safe하지 않다. 따라서 전역으로 선언하면 안되며 반드시 요청/스레드 단위로 사용 후 반환한다.

### 지연 로딩과 즉시 로딩(N+1 해결책 : [참고블로그](https://velog.io/@jinyoungchoi95/JPA-%EB%AA%A8%EB%93%A0-N1-%EB%B0%9C%EC%83%9D-%EC%BC%80%EC%9D%B4%EC%8A%A4%EA%B3%BC-%ED%95%B4%EA%B2%B0%EC%B1%85))
- 연관된 엔티티를 실제 사용 시점에 조회하는 방식
- 장점
  - 초기 로딩 시 불필요한 DB접근 없음
- 단점
  - N+1문제 발생 가능(결국 연관된 엔티티를 검색하기 위해서는 N+1문제가 발생한다.)
  - 해결법 : fetch join(native sql or @EntityGraph)
